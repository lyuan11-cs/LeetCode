1.计数
	-有多少种方式走到右下角；
	-有多少种方法选出k个数 使得和是Sum；
2.求最大最小值
	-从左上角走到右下角路径的最大数字和；
	-最长上升子序列长度；
3.求存在性
	-取石子游戏，先手是否必胜；
	-能不能选出k个数使得和是sum；
	

动态规划解决办法：
1.确定状态
	1.最后一步
	2.子问题
2.转移方程；
	根据子问题定义直接得到
3.初始条件和边界情况；
	细心，考虑周全
4.计算顺序；
	利用之前的计算结果；
􏰹􏰠􏱂􏳠􏰉􏱞􏱇􏳀􏰴􏰰􏰠􏲢
动态规划类型：
求最大最小值动态规划；
存在型动态规划；
计数型动态规划；

坐标性动态规划
序列性动态规划
划分性动态规划

序列性动态规划：...前i个...最小/方式数/可行性

划分型动态规划；

坐标性动态规划：
给定一个序列或网格；
需要找到序列中某个/某些子序列或网格中的某条路径
某种性质最大/最小
计数
存在型

动态规划方程dp[i] 中的下标i表示以ai为结尾的满足条件的子序列的性质，dp[i][j]中的下标i,j表示以格子(i,j)为结尾的满足条件的路径的性质
	最大/最小值
	个数
	是否存在
坐标性动态规划的初始条件dp[0]就是指以a0为结尾的子序列的性质；

滚动数组优化： 
􏳅􏲄􏴙􏰧􏱒􏳆􏳅开数组时， 只开dp[0][0..n-1]和dp[1][0..n-1]
计算􏱼􏵒dp[0][0],..,dp[0][n-1], 􏱼􏵒计算dp[1][0],..,dp[1][n-1]
计算dp[2][0..n-1]时， 􏰧􏱒开dp[2][0..n-1]，删掉􏱒􏲒􏲗dp[0][0..n-1],因为已经不需要􏱒􏲧􏰦􏱊􏲣􏱞􏵜􏵚
dp[0][0..n-1]的值􏵙􏱾􏰨

对于网格上的动态规划，如果dp[i][j] 只依赖于本行的dp[i][x] 与前一行的dp[i-1][y]，那么久可以采用滚动数组的方法压缩空间，空间复杂度为O(N)

如果网格行数少，列数多，那么可以逐列计算，滚动数组的长度为行数，空间复杂度为O(M)

位操作动态规划：
& 与
| 或
^ 异或
！非

二进制表示算法：
第一步：i mod 2 是最低位的bit；
第二步：i <- floor(i/2)， 如果i=0结束，否则回到第一步；

和位操作相关的动态规划一般用值作状态；

序列性动态规划：
给定一个序列；
动态规划方程dp[i]中的下标i表示前i个元素a[0],a[1]...a[i-1]的某种性质；
-坐标型的dp[i]表示以ai为结尾的某种性质；

初始化中，dp[0]表示空序列的性质；
	坐标型动态规划的初始条件dp[0]就是指以a0为结尾的子序列的性质；



